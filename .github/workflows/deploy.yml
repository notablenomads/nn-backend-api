name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_DEFAULT_PLATFORM: linux/arm64
  DOCKER_IMAGE: mrdevx/nn-backend-api
  NODE_ENV: production

jobs:
  pre-deployment-check:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Test Telegram notification
        run: |
          # Just a placeholder to preserve the step name for now
          echo "Skipping pre-deployment notification"

      - name: Verify required secrets
        run: |
          missing_secrets=()

          # Check required secrets
          [ -n "${{ secrets.SERVER_IP }}" ] || missing_secrets+=("SERVER_IP")
          [ -n "${{ secrets.DOCKER_HUB_TOKEN }}" ] || missing_secrets+=("DOCKER_HUB_TOKEN")
          [ -n "${{ secrets.DEPLOY_SSH_KEY }}" ] || missing_secrets+=("DEPLOY_SSH_KEY")
          [ -n "${{ secrets.ENV_FILE }}" ] || missing_secrets+=("ENV_FILE")

          # Optional but recommended secrets
          if [ -z "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] || [ -z "${{ secrets.TELEGRAM_CHAT_ID }}" ] || [ -z "${{ secrets.TELEGRAM_THREAD_ID }}" ]; then
            echo "âš ï¸ Warning: Telegram notification secrets are not set. Notifications will be disabled."
          fi

          # If any required secrets are missing, fail the workflow
          if [ ${#missing_secrets[@]} -ne 0 ]; then
            echo "âŒ Error: The following required secrets are missing:"
            printf '%s\n' "${missing_secrets[@]}"
            exit 1
          fi

          echo "âœ… All required secrets are present"

      - name: Verify SSH connection
        run: |
          # Set up SSH
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Configure SSH
          echo "Host ${{ secrets.SERVER_IP }}" > ~/.ssh/config
          echo "  HostName ${{ secrets.SERVER_IP }}" >> ~/.ssh/config
          echo "  User root" >> ~/.ssh/config
          echo "  IdentityFile ~/.ssh/deploy_key" >> ~/.ssh/config
          echo "  StrictHostKeyChecking accept-new" >> ~/.ssh/config

          # Start SSH agent
          eval $(ssh-agent -s)
          ssh-add ~/.ssh/deploy_key

          # Test SSH connection with retries
          max_retries=3
          retry_count=0
          while [ $retry_count -lt $max_retries ]; do
            if ssh -o BatchMode=yes -o ConnectTimeout=10 root@${{ secrets.SERVER_IP }} "echo 'SSH connection test successful'"; then
              echo "âœ… SSH connection verified successfully"
              exit 0
            fi
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "âš ï¸ SSH connection failed, attempt $retry_count of $max_retries. Retrying in 5 seconds..."
              sleep 5
            fi
          done
          echo "âŒ Error: Failed to establish SSH connection after $max_retries attempts"
          exit 1

      - name: Verify Docker Hub access
        run: |
          echo "${{ secrets.DOCKER_HUB_TOKEN }}" | docker login -u mrdevx --password-stdin
          if ! docker pull ${{ env.DOCKER_IMAGE }}:latest; then
            echo "âŒ Error: Failed to pull Docker image. Please check Docker Hub access and credentials."
            exit 1
          fi
          echo "âœ… Docker Hub access verified successfully"

      - name: Verify environment file
        run: |
          # Create temporary .env.production file for verification
          echo "${{ secrets.ENV_FILE }}" > .env.production.tmp

          # Verify file was created and has content
          if [ ! -s .env.production.tmp ]; then
            echo "âŒ Error: ENV_FILE secret is empty or invalid"
            exit 1
          fi

          # Verify required environment variables
          required_vars=(
            "NODE_ENV"
            "PORT"
            "HOST"
            "API_PREFIX"
            "DATABASE_HOST"
            "DATABASE_PORT"
            "DATABASE_USERNAME"
            "DATABASE_PASSWORD"
            "DATABASE_NAME"
            "JWT_SECRET"
            "JWT_REFRESH_SECRET"
            "ENCRYPTION_KEY"
          )

          missing_vars=()
          invalid_vars=()

          echo "ðŸ” Checking environment variables..."

          for var in "${required_vars[@]}"; do
            if ! grep -q "^${var}=" .env.production.tmp; then
              missing_vars+=("$var")
            else
              # Check if variable has a non-empty value
              value=$(grep "^${var}=" .env.production.tmp | cut -d'=' -f2-)
              if [ -z "$value" ]; then
                invalid_vars+=("$var")
              fi
            fi
          done

          # Special checks for specific variables
          if grep "^NODE_ENV=" .env.production.tmp | grep -qv "production"; then
            echo "âš ï¸ Warning: NODE_ENV should be set to 'production'"
          fi

          if grep "^DATABASE_HOST=" .env.production.tmp | grep -q "localhost"; then
            echo "âš ï¸ Warning: DATABASE_HOST is set to 'localhost'. In Docker environment, it should be 'postgres'"
          fi

          # Report any issues
          if [ ${#missing_vars[@]} -ne 0 ] || [ ${#invalid_vars[@]} -ne 0 ]; then
            echo "âŒ Environment file validation failed!"
            
            if [ ${#missing_vars[@]} -ne 0 ]; then
              echo "Missing variables:"
              printf '  - %s\n' "${missing_vars[@]}"
            fi
            
            if [ ${#invalid_vars[@]} -ne 0 ]; then
              echo "Variables with empty values:"
              printf '  - %s\n' "${invalid_vars[@]}"
            fi
            
            echo "Current .env.production content (sanitized):"
            grep -v "_KEY\|_SECRET\|PASSWORD" .env.production.tmp || true
            
            # Cleanup
            rm -f .env.production.tmp
            exit 1
          fi

          echo "âœ… Environment file verified successfully"
          echo "Found all required environment variables with valid values"

          # Cleanup
          rm -f .env.production.tmp

  deploy:
    name: Deploy to Production
    needs: pre-deployment-check
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    env:
      SERVER_IP: ${{ secrets.SERVER_IP }}
      DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
      AUTO_CONFIRM: true

    steps:
      - name: Debug Trigger Info
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Ref type: ${{ github.ref_type }}"
          echo "SHA: ${{ github.sha }}"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Enable Corepack
        run: corepack enable

      - name: Setup Yarn
        run: corepack prepare yarn@4.6.0 --activate

      - name: Create .yarnrc.yml file
        run: |
          cp .yarnrc.yml-example .yarnrc.yml
          echo "Created .yarnrc.yml file from example"

      - name: Get version from package.json
        id: package_version
        run: echo "VERSION=$(node -p "require('./package.json').version")" >> $GITHUB_ENV

      - name: Verify Docker Hub access
        run: |
          echo "${{ secrets.DOCKER_HUB_TOKEN }}" | docker login -u mrdevx --password-stdin
          if ! docker pull ${{ env.DOCKER_IMAGE }}:latest; then
            echo "âŒ Error: Failed to pull Docker image. Please check Docker Hub access and credentials."
            exit 1
          fi
          echo "âœ… Docker Hub access verified successfully"

      - name: Create .env.production file
        run: |
          # Write environment file
          echo "${{ secrets.ENV_FILE }}" > .env.production

          # Double-check file was created
          if [ ! -s .env.production ]; then
            echo "âŒ Error: Failed to create .env.production or file is empty"
            exit 1
          fi

          echo "âœ… Created .env.production file"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          platforms: linux/arm64

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: mrdevx
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          push: true
          load: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:latest
            ${{ env.DOCKER_IMAGE }}:${{ env.VERSION }}
            ${{ env.DOCKER_IMAGE }}:${{ github.sha }}

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          # Write the SSH key directly (no base64 decoding needed)
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Configure SSH to use the key for our server
          echo "Host ${{ secrets.SERVER_IP }}" > ~/.ssh/config
          echo "  HostName ${{ secrets.SERVER_IP }}" >> ~/.ssh/config
          echo "  User root" >> ~/.ssh/config
          echo "  IdentityFile ~/.ssh/deploy_key" >> ~/.ssh/config
          echo "  StrictHostKeyChecking accept-new" >> ~/.ssh/config

          # Start SSH agent
          eval $(ssh-agent -s)
          ssh-add ~/.ssh/deploy_key

          # Test SSH connection
          ssh -o BatchMode=yes -o ConnectTimeout=10 root@${{ secrets.SERVER_IP }} "echo 'SSH connection test successful'"

      - name: Add known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Run full deployment
        env:
          DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
          AUTO_CONFIRM: true
        run: |
          chmod +x ./scripts/deploy-full.sh
          docker pull ${{ env.DOCKER_IMAGE }}:latest
          ./scripts/deploy-full.sh "$SERVER_IP"

      - name: Send Telegram notification on success
        if: success()
        run: |
          # Function to escape special characters for MarkdownV2
          escape_markdown() {
            local text="$1"
            # Escape each special character individually
            text="${text//\\/\\\\}"  # Must be first
            text="${text//\./\\.}"
            text="${text//\-/\\\-}"
            text="${text//\!/\\\!}"
            text="${text//\+/\\\+}"
            text="${text//\=/\\\=}"
            text="${text//\|/\\\|}"
            text="${text//\{/\\\{}"
            text="${text//\}/\\\}}"
            text="${text//\(/\\\(}"
            text="${text//\)/\\\)}"
            text="${text//\[/\\\[}"
            text="${text//\]/\\\]}"
            text="${text//\*/\\\*}"
            text="${text//\_/\\\_}"
            text="${text//\~/\\\~}"
            text="${text//\`/\\\`}"
            text="${text//\>/\\\>}"
            text="${text//\#/\\\#}"
            echo "$text"
          }

          # Calculate duration properly using workflow start time
          START_TIME=$(date -d "${{ github.event.head_commit.timestamp }}" +%s)
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          DURATION_MIN=$((DURATION / 60))
          DURATION_SEC=$((DURATION % 60))

          # Get deployment info and last 5 commits with better formatting
          COMMIT_HISTORY=$(git log -n 5 --pretty=format:"%h | %an | %s" | while IFS='|' read -r hash author msg; do
            # Trim spaces
            hash=$(echo "$hash" | xargs)
            author=$(echo "$author" | xargs)
            msg=$(echo "$msg" | xargs)
            # Format each commit line
            printf "\\n%s\\n" "commit: ${hash}"
            printf "%s\\n" "by: ${author}"
            printf "%s\\n" "â†’ ${msg}"
            printf "%s\\n" "\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-"
          done)

          # Format the message with minimal special characters
          MESSAGE="âœ¨ *Deployment Complete*%0A%0A"

          # Header with version and branch
          MESSAGE+="ðŸ“Œ *Version:* \`$(escape_markdown "${{ env.VERSION }}")\`%0A"
          MESSAGE+="ðŸŒ¿ *Branch:* \`$(escape_markdown "$BRANCH_NAME")\`%0A"
          MESSAGE+="ðŸ‘¤ *By:* $(escape_markdown "${{ github.actor }}")%0A"
          MESSAGE+="â±ï¸ *Duration:* ${DURATION_MIN}m ${DURATION_SEC}s%0A%0A"

          # Status section
          MESSAGE+="ðŸ“Š *Status:*%0A"
          MESSAGE+="âœ… Tests passed%0A"
          MESSAGE+="âœ… Build successful%0A"
          MESSAGE+="âœ… Deployment complete%0A%0A"

          # Recent changes section
          MESSAGE+="ðŸ“ *Recent Changes:*%0A\`\`\`%0A${COMMIT_HISTORY}%0A\`\`\`%0A%0A"

          # Links section
          MESSAGE+="ðŸ”— *Quick Access:*%0A"
          MESSAGE+="ðŸ“Š Logs: $(escape_markdown "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}")%0A"
          MESSAGE+="ðŸŒ API: api\\.notablenomads\\.com/v1/docs"

          # Send the notification
          curl -s -X POST \
            "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "message_thread_id=${{ secrets.TELEGRAM_THREAD_ID }}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=MarkdownV2"

      - name: Send Telegram notification on failure
        if: failure()
        run: |
          # Function to escape special characters for MarkdownV2
          escape_markdown() {
            local text="$1"
            # Escape each special character individually
            text="${text//\\/\\\\}"  # Must be first
            text="${text//\./\\.}"
            text="${text//\-/\\\-}"
            text="${text//\!/\\\!}"
            text="${text//\+/\\\+}"
            text="${text//\=/\\\=}"
            text="${text//\|/\\\|}"
            text="${text//\{/\\\{}"
            text="${text//\}/\\\}}"
            text="${text//\(/\\\(}"
            text="${text//\)/\\\)}"
            text="${text//\[/\\\[}"
            text="${text//\]/\\\]}"
            text="${text//\*/\\\*}"
            text="${text//\_/\\\_}"
            text="${text//\~/\\\~}"
            text="${text//\`/\\\`}"
            text="${text//\>/\\\>}"
            text="${text//\#/\\\#}"
            echo "$text"
          }

          # Get error context with better commit formatting
          LAST_COMMIT=$(git log -n 1 --pretty=format:"%h | %an | %s")
          IFS='|' read -r hash author msg <<< "$LAST_COMMIT"
          # Trim spaces
          hash=$(echo "$hash" | xargs)
          author=$(echo "$author" | xargs)
          msg=$(echo "$msg" | xargs)

          # Format commit info
          COMMIT_INFO=$(printf "commit: %s\\nby: %s\\nâ†’ %s" "${hash}" "${author}" "${msg}")

          MESSAGE="âš ï¸ *Deployment Failed*%0A%0A"

          # Header with version and branch
          MESSAGE+="ðŸ“Œ *Version:* \`$(escape_markdown "${{ env.VERSION }}")\`%0A"
          MESSAGE+="ðŸŒ¿ *Branch:* \`$(escape_markdown "$BRANCH_NAME")\`%0A"
          MESSAGE+="ðŸ‘¤ *By:* $(escape_markdown "${{ github.actor }}")%0A%0A"

          # Error details
          MESSAGE+="âŒ *Failed Step:* \`$(escape_markdown "$STEP_NAME")\`%0A%0A"

          # Last commit info with better formatting
          MESSAGE+="ðŸ“ *Last Commit:*%0A\`\`\`%0A${COMMIT_INFO}%0A\`\`\`%0A%0A"

          # Help section
          MESSAGE+="ðŸ” *Debug:*%0A"
          MESSAGE+="ðŸ“Š Logs: $(escape_markdown "$WORKFLOW_URL")%0A"
          MESSAGE+="ðŸ’¬ Contact: @mrdevx"

          # Send the notification
          curl -s -X POST \
            "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "message_thread_id=${{ secrets.TELEGRAM_THREAD_ID }}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=MarkdownV2"
